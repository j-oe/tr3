<xsl:stylesheet version="2.0"
	xmlns="http://www.hs-karlsruhe.de/kmm-m/tr3"
	xmlns:g="http://graphml.graphdrawing.org/xmlns"
	xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
	xmlns:y="http://www.yworks.com/xml/graphml">
	<xsl:namespace-alias stylesheet-prefix="#default" result-prefix="g"/>

	<xsl:output method="xml" encoding="UTF-8" />

	<!-- get datakeys generated by yEd -->
	<xsl:variable name="graph.datakey.title"   select="g:graphml/g:key[@attr.name='Beschreibung'][@for='graph']/@id" />
	<xsl:variable name="graph.datakey.id"      select="g:graphml/g:key[@attr.name='id'][@for='node']/@id" />
	<xsl:variable name="graph.datakey.link"    select="g:graphml/g:key[@attr.name='link'][@for='node']/@id" />
	<xsl:variable name="graph.datakey.copy"    select="g:graphml/g:key[@attr.name='copy'][@for='node']/@id" />
	<xsl:variable name="graph.datakey.content" select="g:graphml/g:key[@attr.name='content'][@for='node']/@id" />
	<xsl:variable name="graph.datakey.class"   select="g:graphml/g:key[@attr.name='class'][@for='node']/@id" />
	<xsl:variable name="graph.datakey.valid"   select="g:graphml/g:key[@attr.name='valid'][@for='node']/@id" />
	<xsl:variable name="graph.datakey.invalid" select="g:graphml/g:key[@attr.name='invalid'][@for='node']/@id" />

	<!-- get graph name through description attribute -->
	<xsl:variable name="graph.name"            select="normalize-space(//g:graph/g:data[@key=$graph.datakey.title])" />

	<!-- build variable tree for collecting nodes -->
	<xsl:variable name="graph.layout">
		<!-- get rectangles as branches and add information -->
		<xsl:for-each select="//g:node[g:data[y:ShapeNode]/y:ShapeNode/y:Shape/@type='rectangle']">
			<xsl:variable name="node.id"       select="@id" />
			<xsl:variable name="node.nid"      select="normalize-space(g:data[@key=$graph.datakey.id])" />
			<xsl:variable name="node.out"      select="normalize-space(g:data[y:ShapeNode]/y:ShapeNode/y:NodeLabel[1])" />
			<xsl:variable name="node.content"  select="normalize-space(g:data[@key=$graph.datakey.content])" />
			<xsl:variable name="node.class"    select="normalize-space(g:data[@key=$graph.datakey.class])" />
			<xsl:variable name="node.valid"    select="normalize-space(g:data[@key=$graph.datakey.valid])" />
			<xsl:variable name="node.invalid"    select="normalize-space(g:data[@key=$graph.datakey.invalid])" />
			<xsl:variable name="node.parent"   select="//g:edge[@target=$node.id]/@source" />
			<!-- generate neutral node element, important: parent attribute (either root or id of parent)  -->
			<node id="{$node.id}" nid="{$node.nid}" out="{$node.out}" content="{$node.content}" class="{$node.class}" parent="{if ($node.parent != '') then $node.parent else 'root'}" valid="{$node.valid}" invalid="{$node.invalid}"/>
		</xsl:for-each>
		<!-- get ellipses as copied branches and add information -->
		<xsl:for-each select="//g:node[g:data[y:ShapeNode]/y:ShapeNode/y:Shape/@type='ellipse']">
			<xsl:variable name="node.id"       select="@id" />
			<xsl:variable name="node.copy"     select="normalize-space(g:data[@key=$graph.datakey.copy])" />
			<xsl:variable name="node.parent"   select="//g:edge[@target=$node.id]/@source" />
			<!-- generate ref element with copy attribute -->
			<ref id="{$node.id}" copy="{$node.copy}" parent="{if ($node.parent != '') then $node.parent else 'root'}"/>
		</xsl:for-each>
		<!-- get triangles as copied branches and add information -->
		<xsl:for-each select="//g:node[g:data[y:ShapeNode]/y:ShapeNode/y:Shape/@type='triangle']">
			<xsl:variable name="node.id"       select="@id" />
			<xsl:variable name="node.link"     select="normalize-space(g:data[@key=$graph.datakey.link])" />
			<xsl:variable name="node.parent"   select="//g:edge[@target=$node.id]/@source" />
			<!-- generate ref element with link attribute -->
			<ref id="{$node.id}" link="{$node.link}" parent="{if ($node.parent != '') then $node.parent else 'root'}"/>
		</xsl:for-each>
		<!-- get edges (lines) as links and add information -->
		<xsl:for-each select="//g:edge">
			<xsl:variable name="link.start"    select="@source" />
			<xsl:variable name="link.end"      select="@target" />
			<xsl:variable name="link.label"    select="normalize-space(g:data[y:PolyLineEdge]/y:PolyLineEdge/y:EdgeLabel)" />
			<!-- generate link element with start and end point + label -->
			<link start="{$link.start}" end="{$link.end}" label="{$link.label}" />
		</xsl:for-each>
	</xsl:variable>

	<!-- start to build tree -->
	<xsl:template match="/">
		<xsl:element name="tr3">
			<xsl:variable name="node.out"       select="$graph.layout//g:node[@parent='root']/@out" />
			<xsl:variable name="node.content"   select="$graph.layout//g:node[@parent='root']/@content" />
			<!-- attributes for root element (differ from branch attributes) -->
			<xsl:attribute name="title" select="$graph.name" />
			<xsl:attribute name="out" select="$node.out" />
			<xsl:if test="$node.content != ''">
				<xsl:attribute name="content" select="$node.content" />
			</xsl:if>
			<!-- first call of recursive template 'buildTree' with root node as argument -->
			<xsl:call-template name="buildTree">
				<xsl:with-param name="node" select="$graph.layout//g:node[@parent='root']" />
			</xsl:call-template>
		</xsl:element>
	</xsl:template>

	<!-- build tree based on parent attribute and generate tr3-format -->
	<xsl:template name="buildTree">
		<!-- named template parameter -->
		<xsl:param name="node" />
		<!-- get id of given node -->
		<xsl:variable name="node.id" select="$node/@id" />
		<!-- for each node or ref element build node and call self-->
		<xsl:for-each select="$graph.layout//g:node[@parent=$node.id] | $graph.layout//g:ref[@parent=$node.id]">
			<!-- do this for standard nodes -->
			<xsl:if test="local-name() = 'node'">
				<xsl:variable name="node.id"        select="@id" />
				<xsl:variable name="node.id.custom" select="@nid" />
				<xsl:variable name="node.out"       select="@out" />
				<xsl:variable name="node.content"   select="@content" />
				<xsl:variable name="node.class"     select="@class" />
				<xsl:variable name="node.valid"     select="@valid" />
				<xsl:variable name="node.invalid"     select="@invalid" />
				<!-- if no children, then leaf -->
				<xsl:variable name="node.type" select="if (count($graph.layout//g:*[@parent=$node.id]) = 0) then 'leaf' else 'branch'" />
				<!-- generate element based on given information -->
				<xsl:element name="{$node.type}">
					<xsl:attribute name="out" select="$node.out" />
					<xsl:attribute name="in" select="$graph.layout//g:link[@end=$node.id]/@label" />
					<xsl:if test="$node.id.custom != ''">
						<xsl:attribute name="id" select="$node.id.custom" />
					</xsl:if>
					<xsl:if test="$node.content != ''">
						<xsl:attribute name="content" select="$node.content" />
					</xsl:if>
					<xsl:if test="$node.class != ''">
						<xsl:attribute name="class" select="$node.class" />
					</xsl:if>
					<xsl:if test="$node.valid != ''">
						<xsl:attribute name="valid" select="$node.valid" />
					</xsl:if>
					<xsl:if test="$node.invalid != ''">
						<xsl:attribute name="invalid" select="$node.invalid" />
					</xsl:if>
					<!-- recursive call -->
					<xsl:call-template name="buildTree">
						<xsl:with-param name="node" select="." />
					</xsl:call-template>
				</xsl:element>
			</xsl:if>
			<!-- do this for ref nodes -->
			<xsl:if test="local-name() = 'ref'">
				<xsl:variable name="node.id"   select="@id" />
				<xsl:variable name="ref.link"  select="@link" />
				<xsl:variable name="ref.copy"  select="@copy" />
				<xsl:element name="ref">
					<xsl:attribute name="in" select="$graph.layout//g:link[@end=$node.id]/@label" />
					<xsl:if test="$ref.link != ''">
						<xsl:attribute name="link" select="$ref.link" />
					</xsl:if>
					<xsl:if test="$ref.copy != ''">
						<xsl:attribute name="copy" select="$ref.copy" />
					</xsl:if>
					<!-- recursive call -->
					<xsl:call-template name="buildTree">
						<xsl:with-param name="node" select="." />
					</xsl:call-template>
				</xsl:element>
			</xsl:if>
		</xsl:for-each>
	</xsl:template>
</xsl:stylesheet>